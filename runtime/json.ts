import stringify from "safe-stable-stringify";
import type { GetTagMetadata } from "type-fest";
import type { JsonOf } from "../types/json.d.ts";

/**
 * Converts a value to JSON, while preserving its type for future inspection.
 *
 * Sometimes, we need to stringify a value (e.g., to use the string as a key),
 * but we'd still like to Typescript to track the original type that we
 * stringified, so that we can have type checking on the data we'll get back
 * if/when we JSON.parse the string later. That's what this `jsonStringify`
 * helper function does. See {@link jsonParse}.
 *
 * This string is also "stable", i.e., key insertion order in serialized objects
 * _does not_ affect the final string, which is good for making cache keys.
 *
 * NB: technically, this should return a JsonOf<Jsonify<T>>, but we don't do
 * that for now because using Jsonify almost always runs up against TS stack
 * limits.
 *
 * @param it The value to stringify.
 */
export function jsonStringify<T>(it: T) {
  return stringify(it) as JsonOf<T>;
}

/**
 * Parses the JSON, and returns its original type, for JSON generated by
 * {@link jsonStringify}.
 */
export function jsonParse<T extends JsonOf<unknown>>(it: T) {
  return JSON.parse(it) as GetTagMetadata<T, "JSON">;
}

/**
 * Identical to {@link jsonStringify}, except that it does not normalize the
 * order of object keys in the final, returned string. Therefore, e.g.,
 * `{ a: 0, b: 0 }` and `{ b: 0, a: 0 }` will produce different strings. This is
 * usually not what you want -- it prevents the resulting string from being used
 * reliably as a cache key, e.g. -- but may give slightly better performance.
 */
export function jsonStringifyUnstable<T>(it: T) {
  return JSON.stringify(it) as JsonOf<T>;
}
